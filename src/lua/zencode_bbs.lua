--[[
--This file is part of zenroom
--
--Copyright (C) 2022 Dyne.org foundation
--designed, written and maintained by Alberto Lerda and Denis Roio
--
--This program is free software: you can redistribute it and/or modify
--it under the terms of the GNU Affero General Public License v3.0
--
--This program is distributed in the hope that it will be useful,
--but WITHOUT ANY WARRANTY; without even the implied warranty of
--MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--GNU Affero General Public License for more details.
--
--Along with this program you should have received a copy of the
--GNU Affero General Public License v3.0
--If not, see http://www.gnu.org/licenses/agpl.txt
--
--Last modified by Alberto Lerda
--on Monday, 20th June 2022
--]]

local BBS = require'crypto_bbs'

local function bbs_public_key_f(obj)
    local res = ZEN.get(obj, '.')
    local point = res:zcash_topoint()
    ZEN.assert(
       point ~=  ECP2.infinity(),
       'bbs public key is not valid'
    )
    ZEN.assert(
       point*ECP.order() ==  ECP2.infinity(),
       'bbs public key is not valid'
    )
    return res
end


ZEN.add_schema(
   {
      bbs_public_key = bbs_public_key_f,
      bbs_signature = O.from_base64
   }
)


--[[
    KeyGen takes as input an octet string (of length at least 32 bytes) IKM. 
    IKM MUST be infeasible to guess, e.g. generated by a trusted source of randomness.
    
    For this reason we generate IKM inside of the BBS.keygen() function (see src/lua/crypto_bbs.lua)
    
    KeyGen takes also an optional parameter, key_info. 
    This parameter MAY be used to derive multiple independent keys from the same IKM. 
    By default, key_info is the empty string.
--]]
-- generate the private key
When('create the bbs key',function()
	initkeyring'bbs'
	ACK.keyring.bbs = BBS.keygen()
end)

-- generate the public key
When('create the bbs public key',function()
	empty'bbs public key'
	local sk = havekey'bbs'
	ACK.bbs_public_key = BBS.sk2pk(sk)
	new_codec('bbs public key', { zentype = 'element'})
end)

local function _key_from_secret(sec)
   local sk = have(sec)
   initkeyring'bbs'
   -- Check if the user-provided sk is reasonable
   assert(type(sk) == "zenroom.big", "sk must have type integer")
   assert(sk < ECP.order(), "sk is not a scalar")
   ACK.keyring.bbs = sk
end

When("create the bbs key with secret key ''",
     _key_from_secret
)

When("create the bbs key with secret ''",
     _key_from_secret
)

When("create the bbs public key with secret key ''",function(sec)
	local sk = have(sec)
    -- Check if the user-provided sk is reasonable
    assert(type(sk) == "zenroom.big", "sk must have type integer")
    assert(sk < ECP.order(), "sk is not a scalar")

	empty'bbs public key'
	ACK.bbs_public_key = BBS.sk2pk(sk)
	new_codec('bbs public key', { zentype = 'element'})
end)

--[[ The function BBS.sign may take as input also a string octet HEADER containing context 
     and application specific information. If not supplied, it defaultsto an empty string.
--]]
When("create the bbs signature of '' using ''", function(doc, h)
    local sk = havekey'bbs'
    local obj = have(doc)
    local hash = O.to_string(mayhave(h)) or h
    local ciphersuite = BBS.ciphersuite(hash)
    if (type(obj) ~= 'table') then
        obj = {obj}
    end
    local pk = ACK.bbs_public_key or BBS.sk2pk(sk)
    
    empty'bbs signature'
    ACK.bbs_signature = BBS.sign(ciphersuite, sk, pk, obj)
    new_codec('bbs signature', { zentype = 'element'})
    
end)


IfWhen("verify the '' has a bbs signature in '' by '' using ''", function (doc, sig, by, h)
    local pk = load_pubkey_compat(by, 'bbs')
    local hash = O.to_string(mayhave(h)) or h
    local obj = have(doc)
    local ciphersuite = BBS.ciphersuite(hash)
    if (type(obj) ~= 'table') then
        obj = {obj}
    end
    local s = have(sig)
    ZEN.assert(
        BBS.verify(ciphersuite, pk, s, obj),
       'The bbs signature by '..by..' is not authentic'
    )
end)
