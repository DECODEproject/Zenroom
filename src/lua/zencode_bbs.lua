--[[
--This file is part of zenroom
--
--Copyright (C) 2022 Dyne.org foundation
--designed, written and maintained by Alberto Lerda and Denis Roio
--
--This program is free software: you can redistribute it and/or modify
--it under the terms of the GNU Affero General Public License v3.0
--
--This program is distributed in the hope that it will be useful,
--but WITHOUT ANY WARRANTY; without even the implied warranty of
--MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--GNU Affero General Public License for more details.
--
--Along with this program you should have received a copy of the
--GNU Affero General Public License v3.0
--If not, see http://www.gnu.org/licenses/agpl.txt
--
--Last modified by Alberto Lerda
--on Monday, 20th June 2022
--]]

local BBS = require'crypto_bbs'

local function bbs_public_key_f(obj)
    local point = obj:zcash_topoint()
    ZEN.assert(
       point ~=  ECP2.infinity(),
       'bbs public key is not valid'
    )
    ZEN.assert(
       point*ECP.order() ==  ECP2.infinity(),
       'bbs public key is not valid'
    )
    return obj
end


ZEN.add_schema(
   {
      bbs_public_key = function(obj)
        return ZEN.get(obj, '.', bbs_public_key_f)
      end,
      bbs_signature = O.from_base64
   }
)

--[[
    KeyGen takes as input an octet string (of length at least 32 bytes) IKM. 
    IKM MUST be infeasible to guess, e.g. generated by a trusted source of randomness.
    
    For this reason we generate IKM inside of the BBS.keygen() function (see src/lua/crypto_bbs.lua)
    
    KeyGen takes also an optional parameter, key_info. 
    This parameter MAY be used to derive multiple independent keys from the same IKM. 
    By default, key_info is the empty string.
--]]

-- generate the private key
When('create the bbs key',function()
	initkeyring'bbs'
	ACK.keyring.bbs = BBS.keygen()
end)

-- generate the public key
When('create the bbs public key',function()
	empty'bbs public key'
	local sk = havekey'bbs'
	ACK.bbs_public_key = BBS.sk2pk(sk)
	new_codec('bbs public key', { zentype = 'element'})
end)

local function _key_from_secret(sec)
   local sk = have(sec)
   initkeyring'bbs'
   -- Check if the user-provided sk is reasonable
   assert(type(sk) == "zenroom.big", "sk must have type integer")
   assert(sk < ECP.order(), "sk is not a scalar")
   ACK.keyring.bbs = sk
end

When("create the bbs key with secret key ''",
     _key_from_secret
)

When("create the bbs key with secret ''",
     _key_from_secret
)

When("create the bbs public key with secret key ''",function(sec)
	local sk = have(sec)
    -- Check if the user-provided sk is reasonable
    assert(type(sk) == "zenroom.big", "sk must have type integer")
    assert(sk < ECP.order(), "sk is not a scalar")

	empty'bbs public key'
	ACK.bbs_public_key = BBS.sk2pk(sk)
	new_codec('bbs public key', { zentype = 'element'})
end)

--[[ The function BBS.sign may take as input also a string octet HEADER containing context 
     and application specific information. If not supplied, it defaults to an empty string.
--]]

local function generic_bbs_signature(doc, h)
    local sk = havekey'bbs'
    local obj = have(doc)
    local hash = O.to_string(mayhave(h)) or h
    local ciphersuite = BBS.ciphersuite(hash)
    if (type(obj) ~= 'table') then
        obj = {obj}
    end
    local pk = ACK.bbs_public_key or BBS.sk2pk(sk)

    empty'bbs signature'
    ACK.bbs_signature = BBS.sign(ciphersuite, sk, pk, obj)
    new_codec('bbs signature', { zentype = 'element'})

end

When("create the bbs signature of ''", function(doc)
    return generic_bbs_signature(doc, 'shake256')
end)

When("create the bbs signature of '' using ''", generic_bbs_signature)


local function generic_verify(doc, sig, by, h)
    local pk = load_pubkey_compat(by, 'bbs')
    local hash = O.to_string(mayhave(h)) or h
    local obj = have(doc)
    local ciphersuite = BBS.ciphersuite(hash)
    if (type(obj) ~= 'table') then
        obj = {obj}
    end
    local s = have(sig)
    ZEN.assert(
        BBS.verify(ciphersuite, pk, s, obj),
       'The bbs signature by '..by..' is not authentic'
    )
end

IfWhen("verify the '' has a bbs signature in '' by ''", function(doc, sig, by)
    return generic_verify(doc, sig, by, 'shake256')
end)

IfWhen("verify the '' has a bbs signature in '' by '' using ''", generic_verify)

--[[
    Participant generates proof with the function bbs.ProofGen(ciphersuite, pk, signature, 
    header, ph, messages_octets, disclosed_indexes)

    ph = presentation header, used to mitigate replay attack.
    TODO: is it ok to generate it randomly?
--]]

ZEN.add_schema(
    {
        bbs_proof = function(obj)
            return ZEN.get(obj, '.')
        end,
        bbs_credential = O.from_base64,
        bbs_presentation_header = O.from_base64
    }
)

When("create the bbs disclosed messages", function()
    local dis_ind = have'bbs disclosed indexes'
    local all_msgs = have'bbs messages'

    empty'bbs disclosed messages'
    local dis_msgs = {}
    for k,v in pairs(dis_ind) do
        dis_msgs[k] = all_msgs[tonumber(v)]
    end
    ACK.bbs_disclosed_messages = dis_msgs
    new_codec('bbs disclosed messages', { zentype = 'array', encoding = 'string'})
end)

When("create the bbs proof using ''", function(h)
    local hash =  O.to_string(mayhave(h)) or h
    local ciphersuite = BBS.ciphersuite(hash)
    local ph = have'bbs presentation header'
    local message_octets = have'bbs messages'
    if(type(message_octets) ~= 'table') then
        message_octets = {message_octets}
    end
    local float_indexes = have'bbs disclosed indexes'
    local disclosed_indexes = {}
    for k,v in pairs(float_indexes) do
        disclosed_indexes[k] = tonumber(v)
    end

    local pubk = have'bbs public key'
    local signature = have'bbs credential'

    empty'bbs proof'
    ACK.bbs_proof = BBS.ProofGen(ciphersuite, pubk, signature, nil, ph, message_octets, disclosed_indexes)
    new_codec('bbs proof', { zentype = 'element'})
end)


IfWhen("verify the bbs proof using ''", function(h)
    local hash =  O.to_string(mayhave(h)) or h
    local ciphersuite = BBS.ciphersuite(hash)
    local pubk = have'bbs public key'
    local proof = have'bbs proof'
    local ph = have'bbs presentation header'
    local disclosed_messages_octets = have'bbs disclosed messages'
    local float_indexes = have'bbs disclosed indexes'
    local disclosed_indexes = {}
    for k,v in pairs(float_indexes) do
        disclosed_indexes[k] = tonumber(v)
    end
    ZEN.assert(
        BBS.ProofVerify(ciphersuite, pubk, proof, nil, ph, disclosed_messages_octets, disclosed_indexes),
       'The bbs proof is not valid')
end)


